// We emulate FLT_MAX from <float.h>
const float FLT_MAX_GLSL = 3.402823466e+38;

vec3 loadVertex(uint vi)
{
    uint base = 3u * vi;
    return vec3(
        vertices[base + 0u],
        vertices[base + 1u],
        vertices[base + 2u]
    );
}

uvec3 loadFace(uint fi)
{
    uint base = 3u * fi;
    return uvec3(
        faces[base + 0u],
        faces[base + 1u],
        faces[base + 2u]
    );
}

vec3 cross_f3(vec3 a, vec3 b)
{
    return cross(a, b);
}

vec3 normalize_f3(vec3 v)
{
    float inv = inversesqrt(dot(v, v) + 1e-20);
    return v * inv;
}

float length_f3(vec3 v)
{
    return length(v);
}

// dot/cross for vec3
float dot3(vec3 a, vec3 b)
{
    return dot(a, b);
}

vec3 cross3(vec3 a, vec3 b)
{
    return cross(a, b);
}

// Möller–Trumbore: ray_o + t*ray_d vs triangle (v0,v1,v2)
// Returns true on hit; outputs t (distance), u,v (barycentrics). w = 1-u-v.
// tMin/tMax control valid interval; set tMin=0.0, tMax=FLT_MAX_GLSL for "any".
bool intersect_ray_triangle(vec3  ray_o, vec3  ray_d,
                            vec3  v0,    vec3  v1,    vec3  v2,
                            float tMin,  float tMax,
                            bool  backface_cull,
                            out float t, out float u, out float v)
{
    // Edges
    vec3 e1 = v1 - v0;
    vec3 e2 = v2 - v0;

    // pvec = d x e2
    vec3 pvec = cross3(ray_d, e2);
    float det = dot3(e1, pvec);

    float eps = 1e-8; // geometric epsilon

    if (backface_cull)
    {
        if (det <= eps)
            return false;
    }
    else
    {
        if (abs(det) <= eps)
            return false;
    }

    float invDet = 1.0 / det;

    // s = o - v0; u = (s·pvec)/det
    vec3 s = ray_o - v0;
    u = dot3(s, pvec) * invDet;
    if (u < 0.0 || u > 1.0)
        return false;

    // qvec = s x e1; v = (d·qvec)/det
    vec3 qvec = cross3(s, e1);
    v = dot3(ray_d, qvec) * invDet;
    if (v < 0.0 || (u + v) > 1.0)
        return false;

    // t = (e2·qvec)/det
    t = dot3(e2, qvec) * invDet;
    if (t < tMin || t > tMax)
        return false;

    return true;
}

// Convenience wrapper: any-hit with default interval [0, +inf)
bool intersect_ray_triangle_any(vec3  ray_o, vec3  ray_d,
                                vec3  v0,    vec3  v1,    vec3  v2,
                                bool  backface_cull,
                                out float t, out float u, out float v)
{
    return intersect_ray_triangle(
        ray_o, ray_d,
        v0, v1, v2,
        0.0, FLT_MAX_GLSL,
        backface_cull,
        t, u, v
    );
}

// Ray vs AABB slab test
// ray_o + t * ray_d, t in [tMin, tMax]
// Returns true on hit; outputs tHitNear (entry) and tHitFar (exit)
bool intersect_ray_aabb(vec3 ray_o, vec3 ray_d,
                        AABBGPU box,
                        float tMin, float tMax,
                        out float tHitNear, out float tHitFar)
{
    float t0 = tMin;
    float t1 = tMax;

    float eps = 1e-8; // geometric epsilon for parallel check

    // X slab
    if (abs(ray_d.x) < eps)
    {
        // Ray is parallel to X planes; must be inside slab
        if (ray_o.x < box.min_x || ray_o.x > box.max_x)
            return false;
    }
    else
    {
        float invDx = 1.0 / ray_d.x;
        float tx0 = (box.min_x - ray_o.x) * invDx;
        float tx1 = (box.max_x - ray_o.x) * invDx;
        if (invDx < 0.0)
        {
            float tmp = tx0; tx0 = tx1; tx1 = tmp;
        }
        if (tx0 > t0) t0 = tx0;
        if (tx1 < t1) t1 = tx1;
        if (t1 < t0) return false;
    }

    // Y slab
    if (abs(ray_d.y) < eps)
    {
        if (ray_o.y < box.min_y || ray_o.y > box.max_y)
            return false;
    }
    else
    {
        float invDy = 1.0 / ray_d.y;
        float ty0 = (box.min_y - ray_o.y) * invDy;
        float ty1 = (box.max_y - ray_o.y) * invDy;
        if (invDy < 0.0)
        {
            float tmp = ty0; ty0 = ty1; ty1 = tmp;
        }
        if (ty0 > t0) t0 = ty0;
        if (ty1 < t1) t1 = ty1;
        if (t1 < t0) return false;
    }

    // Z slab
    if (abs(ray_d.z) < eps)
    {
        if (ray_o.z < box.min_z || ray_o.z > box.max_z)
            return false;
    }
    else
    {
        float invDz = 1.0 / ray_d.z;
        float tz0 = (box.min_z - ray_o.z) * invDz;
        float tz1 = (box.max_z - ray_o.z) * invDz;
        if (invDz < 0.0)
        {
            float tmp = tz0; tz0 = tz1; tz1 = tmp;
        }
        if (tz0 > t0) t0 = tz0;
        if (tz1 < t1) t1 = tz1;
        if (t1 < t0) return false;
    }

    tHitNear = t0;
    tHitFar  = t1;
    return true;
}

// Convenience wrapper: any-hit with default interval [0, +inf)
bool intersect_ray_aabb_any(vec3 ray_o, vec3 ray_d,
                            AABBGPU box,
                            out float tHitNear, out float tHitFar)
{
    return intersect_ray_aabb(ray_o, ray_d, box,
                              0.0, FLT_MAX_GLSL,
                              tHitNear, tHitFar);
}
