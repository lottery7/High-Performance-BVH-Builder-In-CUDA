#version 450

#include <libgpu/vulkan/vk/common.vk>

#include "../defines.h"
#include "../shared_structs/camera_gpu_shared.h"
#include "../shared_structs/aabb_gpu_shared.h"

// Buffers: adjust binding indices to match your host side
layout (std430, binding = 0) readonly buffer VerticesIn
{
    float vertices[];
};

layout (std430, binding = 1) readonly buffer FacesIn
{
    uint faces[];
};

layout (std430, binding = 2) writeonly buffer FramebufferFaceIdOut
{
    int framebuffer_face_id[];
};

layout (std430, binding = 3) writeonly buffer FramebufferAOOut
{
    float framebuffer_ambient_occlusion[];
};

layout (std430, binding = 4) readonly buffer CameraBuffer
{
    CameraViewGPU camera;
};

// Push constants: number of faces
layout (push_constant) uniform PushConstants
{
    uint nfaces;
} params;

// Workgroup size (tune or map to your defines)
layout (local_size_x = GROUP_SIZE_X, local_size_y = GROUP_SIZE_Y) in;

// ==== helpers from camera_helpers.cu ====
vec3 normalize3(vec3 v)
{
    float inv = inversesqrt(dot(v, v));
    return v * inv;
}

void make_primary_ray(in CameraViewGPU cam, float u, float v,
                      out vec3 ray_o, out vec3 ray_d)
{
    float x_cam = (u - cam.K.cx) / cam.K.fx;
    float y_cam = -(v - cam.K.cy) / cam.K.fy;
    float z_cam = -1.0;

    float dx = cam.E.R[0] * x_cam + cam.E.R[3] * y_cam + cam.E.R[6] * z_cam;
    float dy = cam.E.R[1] * x_cam + cam.E.R[4] * y_cam + cam.E.R[7] * z_cam;
    float dz = cam.E.R[2] * x_cam + cam.E.R[5] * y_cam + cam.E.R[8] * z_cam;

    ray_o = vec3(cam.E.C[0], cam.E.C[1], cam.E.C[2]);
    ray_d = normalize3(vec3(dx, dy, dz));
}

// ==== helpers from geometry_helpers.cu ====
const float FLT_MAX_GLSL = 3.402823466e+38;

vec3 loadVertex(uint vi)
{
    uint base = 3u * vi;
    return vec3(
        vertices[base + 0u],
        vertices[base + 1u],
        vertices[base + 2u]
    );
}

uvec3 loadFace(uint fi)
{
    uint base = 3u * fi;
    return uvec3(
        faces[base + 0u],
        faces[base + 1u],
        faces[base + 2u]
    );
}

vec3 cross_f3(vec3 a, vec3 b)
{
    return cross(a, b);
}

vec3 normalize_f3(vec3 v)
{
    float inv = inversesqrt(dot(v, v) + 1e-20);
    return v * inv;
}

float length_f3(vec3 v)
{
    return length(v);
}

float dot3(vec3 a, vec3 b)
{
    return dot(a, b);
}

vec3 cross3(vec3 a, vec3 b)
{
    return cross(a, b);
}

bool intersect_ray_triangle(vec3  ray_o, vec3  ray_d,
                            vec3  v0,    vec3  v1,    vec3  v2,
                            float tMin,  float tMax,
                            bool  backface_cull,
                            out float t, out float u, out float v)
{
    vec3 e1 = v1 - v0;
    vec3 e2 = v2 - v0;

    vec3 pvec = cross3(ray_d, e2);
    float det = dot3(e1, pvec);

    float eps = 1e-8;

    if (backface_cull)
    {
        if (det <= eps)
            return false;
    }
    else
    {
        if (abs(det) <= eps)
            return false;
    }

    float invDet = 1.0 / det;

    vec3 s = ray_o - v0;
    u = dot3(s, pvec) * invDet;
    if (u < 0.0 || u > 1.0)
        return false;

    vec3 qvec = cross3(s, e1);
    v = dot3(ray_d, qvec) * invDet;
    if (v < 0.0 || (u + v) > 1.0)
        return false;

    t = dot3(e2, qvec) * invDet;
    if (t < tMin || t > tMax)
        return false;

    return true;
}

bool intersect_ray_aabb(vec3 ray_o, vec3 ray_d,
                        AABBGPU box,
                        float tMin, float tMax,
                        out float tHitNear, out float tHitFar)
{
    float t0 = tMin;
    float t1 = tMax;

    float eps = 1e-8;

    // X slab
    if (abs(ray_d.x) < eps)
    {
        if (ray_o.x < box.min_x || ray_o.x > box.max_x)
            return false;
    }
    else
    {
        float invDx = 1.0 / ray_d.x;
        float tx0 = (box.min_x - ray_o.x) * invDx;
        float tx1 = (box.max_x - ray_o.x) * invDx;
        if (invDx < 0.0)
        {
            float tmp = tx0; tx0 = tx1; tx1 = tmp;
        }
        if (tx0 > t0) t0 = tx0;
        if (tx1 < t1) t1 = tx1;
        if (t1 < t0) return false;
    }

    // Y slab
    if (abs(ray_d.y) < eps)
    {
        if (ray_o.y < box.min_y || ray_o.y > box.max_y)
            return false;
    }
    else
    {
        float invDy = 1.0 / ray_d.y;
        float ty0 = (box.min_y - ray_o.y) * invDy;
        float ty1 = (box.max_y - ray_o.y) * invDy;
        if (invDy < 0.0)
        {
            float tmp = ty0; ty0 = ty1; ty1 = tmp;
        }
        if (ty0 > t0) t0 = ty0;
        if (ty1 < t1) t1 = ty1;
        if (t1 < t0) return false;
    }

    // Z slab
    if (abs(ray_d.z) < eps)
    {
        if (ray_o.z < box.min_z || ray_o.z > box.max_z)
            return false;
    }
    else
    {
        float invDz = 1.0 / ray_d.z;
        float tz0 = (box.min_z - ray_o.z) * invDz;
        float tz1 = (box.max_z - ray_o.z) * invDz;
        if (invDz < 0.0)
        {
            float tmp = tz0; tz0 = tz1; tz1 = tmp;
        }
        if (tz0 > t0) t0 = tz0;
        if (tz1 < t1) t1 = tz1;
        if (t1 < t0) return false;
    }

    tHitNear = t0;
    tHitFar  = t1;
    return true;
}

// RNG helper
float random01(inout uint s)
{
    s = s * 1664525u + 1013904223u;
    return float(s >> 8u) * (1.0 / 16777216.0);
}

// Cast a single ray and report if ANY triangle is hit
bool any_hit_from(vec3 orig, vec3 dir, uint nfaces, int ignore_face)
{
    float t, u, v;
    float tMin = 1e-4;
    float tMax = FLT_MAX_GLSL;

    for (uint fi = 0u; fi < nfaces; ++fi)
    {
        if (int(fi) == ignore_face)
            continue;

        uvec3 f = loadFace(fi);
        vec3 a = loadVertex(f.x);
        vec3 b = loadVertex(f.y);
        vec3 c = loadVertex(f.z);

        // Use same backface mode as primary rays (here: false)
        if (intersect_ray_triangle(orig, dir,
                                   a, b, c,
                                   tMin, tMax,
                                   false, t, u, v))
        {
            return true;
        }
    }
    return false;
}

// Build tangent basis for a given normal
void make_basis(vec3 n, out vec3 t, out vec3 b)
{
    // pick a non-parallel vector
    vec3 up = (abs(n.z) < 0.999) ? vec3(0.0, 0.0, 1.0)
                                 : vec3(0.0, 1.0, 0.0);
    t = normalize_f3(cross_f3(up, n));
    b = cross_f3(n, t);
}

void main()
{
    uint i = gl_GlobalInvocationID.x;
    uint j = gl_GlobalInvocationID.y;

    rassert(camera.magic_bits_guard == CAMERA_VIEW_GPU_MAGIC_BITS_GUARD, 246435342);
    if (i >= uint(camera.K.width) || j >= uint(camera.K.height))
        return;

    vec3 ray_origin;
    vec3 ray_direction;
    make_primary_ray(camera,
                     float(i) + 0.5,
                     float(j) + 0.5,
                     ray_origin, ray_direction);

    float tMin  = 1e-6;
    float tBest = FLT_MAX_GLSL;
    float uBest = 0.0;
    float vBest = 0.0;
    int   faceIdBest = -1;

    for (uint fi = 0u; fi < params.nfaces; ++fi)
    {
        float t, u, v;
        uvec3 face = loadFace(fi);
        vec3 v0 = loadVertex(face.x);
        vec3 v1 = loadVertex(face.y);
        vec3 v2 = loadVertex(face.z);

        if (intersect_ray_triangle(ray_origin, ray_direction,
                                   v0, v1, v2,
                                   tMin, tBest,
                                   false, t, u, v))
        {
            tBest      = t;
            faceIdBest = int(fi);
            uBest      = u;
            vBest      = v;
        }
    }

    uint idx = j * uint(camera.K.width) + i;
    framebuffer_face_id[idx] = faceIdBest;

    float ao = 1.0; // background stays white

    if (faceIdBest >= 0)
    {
        uvec3 f = loadFace(uint(faceIdBest));
        vec3 a = loadVertex(f.x);
        vec3 b = loadVertex(f.y);
        vec3 c = loadVertex(f.z);

        vec3 e1 = b - a;
        vec3 e2 = c - a;
        vec3 n  = normalize_f3(cross_f3(e1, e2));

        // ensure hemisphere is "outside" relative to the camera ray
        if (dot(n, ray_direction) > 0.0)
            n = -n;

        vec3 P = ray_origin + tBest * ray_direction;

        float scale = max(max(length_f3(e1), length_f3(e2)),
                          length_f3(c - a));
        float eps   = 1e-3 * max(1.0, scale);
        vec3 Po     = P + n * eps;

        // build tangent basis
        vec3 T, B;
        make_basis(n, T, B);

        // per-pixel seed (stable)
        uint tBestBits = floatBitsToUint(tBest);
        uint rng = 0x9E3779B9u ^ idx ^ tBestBits;

        int hits = 0;
        for (int s = 0; s < AO_SAMPLES; ++s)
        {
            // uniform hemisphere sampling (solid angle)
            float u1 = random01(rng);
            float u2 = random01(rng);

            float z  = u1;                        // z in [0,1]
            float phi = 6.28318530718 * u2;       // 2*pi*u2
            float r  = sqrt(max(0.0, 1.0 - z * z));

            vec3 d_local = vec3(r * cos(phi),
                                r * sin(phi),
                                z);

            // transform to world space
            vec3 d = vec3(
                T.x * d_local.x + B.x * d_local.y + n.x * d_local.z,
                T.y * d_local.x + B.y * d_local.y + n.y * d_local.z,
                T.z * d_local.x + B.z * d_local.y + n.z * d_local.z
            );

            if (any_hit_from(Po, d, params.nfaces, faceIdBest))
                ++hits;
        }

        ao = 1.0 - float(hits) / float(AO_SAMPLES); // [0,1]
    }

    framebuffer_ambient_occlusion[idx] = ao;
}
